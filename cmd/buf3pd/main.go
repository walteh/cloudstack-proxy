package main

import (
	"context"
	"crypto/sha256"
	"encoding/hex"
	"flag"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/rs/zerolog"
	"gitlab.com/tozd/go/errors"
	"gopkg.in/yaml.v3"
)

// Version will be set during build
var Version = "dev"

type Buf3pdDep struct {
	Type string `yaml:"type"`
	Repo string `yaml:"repo"`
	Path string `yaml:"path"`
	Ref  string `yaml:"ref"`
}

// Buf3pdConfig represents the configuration structure in buf.yaml
type Buf3pdConfig struct {
	Path string      `yaml:"path"`
	Deps []Buf3pdDep `yaml:"deps"`
}

// BufYaml represents the buf.yaml file structure
type BufYaml struct {
	Version  string                 `yaml:"version"`
	Modules  []map[string]string    `yaml:"modules"`
	Breaking map[string]interface{} `yaml:"breaking"`
	Deps     []string               `yaml:"deps"`
	Lint     map[string]interface{} `yaml:"lint"`
	Buf3pd   Buf3pdConfig           `yaml:"buf3pd"`
}

// LockDep represents a dependency entry in the lock file
type LockDep struct {
	Type   string `yaml:"type"`
	Repo   string `yaml:"repo"`
	Path   string `yaml:"path"`
	Ref    string `yaml:"ref"`
	Commit string `yaml:"commit"`
	Digest string `yaml:"digest"`
}

// LockFile represents the structure of the buf3pd.lock.yaml file
type LockFile struct {
	Version string     `yaml:"version"`
	Deps    []*LockDep `yaml:"deps"`
}

func main() {
	ctx := context.Background()
	logger := zerolog.New(os.Stdout).With().Timestamp().Logger()
	ctx = logger.WithContext(ctx)

	log := zerolog.Ctx(ctx)
	log.Info().Str("version", Version).Msg("starting buf3pd")

	// Parse command line flags
	var (
		bufYamlPath = flag.String("config", "buf.yaml", "Path to buf.yaml file")
		workDir     = flag.String("workdir", ".", "Working directory")
	)
	flag.Parse()

	// Ensure workDir is absolute
	absWorkDir, err := filepath.Abs(*workDir)
	if err != nil {
		log.Fatal().Err(errors.Errorf("resolving absolute path for workdir: %w", err)).Msg("failed to start")
	}

	cfg, err := readBuf3pdConfig(filepath.Join(absWorkDir, *bufYamlPath))
	if err != nil {
		log.Fatal().Err(errors.Errorf("reading buf3pd config: %w", err)).Msg("failed to read buf3pd config")
	}

	// Process dependencies
	lockFile, err := readLockFile(filepath.Join(absWorkDir, "buf3pd.lock.yaml"))
	if err != nil {
		log.Fatal().Err(errors.Errorf("reading lock file: %w", err)).Msg("failed to read lock file")
	}

	depFilesToUpdate := []*DepFiles{}

	for _, dep := range cfg.Deps {
		if dep.Type != "git" {
			log.Warn().Str("type", dep.Type).Msg("unsupported dependency type, skipping")
			continue
		}

		tryLoc, ok, err := NewDepFilesFromLocal(ctx, dep, dep.Path)
		if err != nil {
			log.Fatal().Err(errors.Errorf("processing git dependency: %w", err)).Msg("failed to process git dependency")
		}
		storedLockDep := lockFile.EntryFor(dep)

		if ok {
			realLockDep, err := tryLoc.LockEntry()
			if err != nil {
				log.Fatal().Err(errors.Errorf("creating lock entry: %w", err)).Msg("failed to create lock entry")
			}

			if storedLockDep != nil && storedLockDep.Compare(realLockDep) {
				log.Info().Str("repo", dep.Repo).Str("path", dep.Path).Str("ref", dep.Ref).Msg("dependency already processed")
				continue
			}

		}

		log.Info().Str("repo", dep.Repo).Str("path", dep.Path).Str("ref", dep.Ref).Msg("processing git dependency")

		depFiles, err := NewDepFilesFromRemote(dep)
		if err != nil {
			log.Fatal().Err(errors.Errorf("processing git dependency: %w", err)).Msg("failed to process git dependency")
		}

		lockDep, err := depFiles.LockEntry()
		if err != nil {
			log.Fatal().Err(errors.Errorf("creating lock entry: %w", err)).Msg("failed to create lock entry")
		}

		if storedLockDep != nil {
			*storedLockDep = *lockDep
		} else {
			lockFile.Deps = append(lockFile.Deps, lockDep)
		}

		depFilesToUpdate = append(depFilesToUpdate, depFiles)

		log.Info().Str("repo", dep.Repo).Str("commit", depFiles.Commit).Msg("successfully processed dependency")
	}

	for _, depFiles := range depFilesToUpdate {
		err := depFiles.WriteToDir(filepath.Join(absWorkDir, depFiles.DepInfo.Path))
		if err != nil {
			log.Fatal().Err(errors.Errorf("writing dependency files: %w", err)).Msg("failed to write dependency files")
		}
	}

	// Write the lock file
	lockFileContent, err := yaml.Marshal(lockFile)
	if err != nil {
		log.Fatal().Err(errors.Errorf("marshaling lock file: %w", err)).Msg("failed to create lock file")
	}

	lockFilePath := filepath.Join(absWorkDir, "buf3pd.lock.yaml")
	if err := os.WriteFile(lockFilePath, []byte("# Generated by buf3pd. DO NOT EDIT.\n"+string(lockFileContent)), 0644); err != nil {
		log.Fatal().Err(errors.Errorf("writing lock file: %w", err)).Msg("failed to write lock file")
	}

	log.Info().Str("path", lockFilePath).Msg("created lock file")
	log.Info().Msg("buf3pd completed successfully")
}

func readLockFile(path string) (*LockFile, error) {
	content, err := os.ReadFile(path)
	if err != nil {
		if os.IsNotExist(err) {
			return &LockFile{
				Version: "v2",
				Deps:    []*LockDep{},
			}, nil
		}
		return nil, errors.Errorf("reading lock file: %w", err)
	}

	var lockFile LockFile
	if err := yaml.Unmarshal(content, &lockFile); err != nil {
		return nil, errors.Errorf("unmarshalling lock file: %w", err)
	}

	return &lockFile, nil
}

func readBuf3pdConfig(path string) (*Buf3pdConfig, error) {
	// Parse buf.yaml
	bufYamlContent, err := os.ReadFile(path)
	if err != nil {
		return nil, errors.Errorf("reading buf.yaml: %w", err)
	}

	// Split by "---" to find the sections
	sections := strings.Split(string(bufYamlContent), "---")
	if len(sections) < 2 {
		return nil, errors.New("buf.yaml does not contain the expected sections separated by '---'")
	}

	if len(sections) < 2 {
		return nil, errors.New("buf.yaml does not contain the expected sections separated by '---'")
	}

	content := sections[1]

	var buf3pdConfig Buf3pdConfig
	if err := yaml.Unmarshal([]byte(content), &buf3pdConfig); err != nil {
		return nil, errors.Errorf("unmarshalling buf3pd config: %w", err)
	}

	return &buf3pdConfig, nil
}

type DepFiles struct {
	DepInfo Buf3pdDep         `yaml:"dep"`
	Files   map[string][]byte `yaml:"files"`
	Commit  string            `yaml:"commit"`
}

func NewDepFilesFromLocal(ctx context.Context, dep Buf3pdDep, path string) (*DepFiles, bool, error) {
	files, err := filepath.Glob(filepath.Join(path, "**/*.proto"))
	if err != nil {
		return nil, false, errors.Errorf("getting files: %w", err)
	}

	depFiles := &DepFiles{
		DepInfo: dep,
		Files:   make(map[string][]byte),
	}

	for _, file := range files {
		content, err := os.ReadFile(file)
		if err != nil {
			return nil, false, errors.Errorf("reading file: %w", err)
		}
		depFiles.Files[file] = content
	}

	depFiles.Commit = "local"

	// try to get the commit hash from the commit.txt file
	commitFile := filepath.Join(path, "commit.txt")
	if _, err := os.Stat(commitFile); err == nil {
		commit, err := os.ReadFile(commitFile)
		if err != nil {
			return nil, false, errors.Errorf("reading commit file: %w", err)
		}
		depFiles.Commit = strings.TrimSpace(string(commit))
	} else {
		zerolog.Ctx(ctx).Warn().Str("path", commitFile).Msg("commit.txt file not found, using local commit")
	}

	return depFiles, true, nil
}

func NewDepFilesFromRemote(dep Buf3pdDep) (*DepFiles, error) {
	tempDir, err := os.MkdirTemp("", "buf3pd-git-")
	if err != nil {
		return nil, errors.Errorf("creating temp directory: %w", err)
	}
	defer os.RemoveAll(tempDir)

	// Clone the repository
	cmd := exec.Command("git", "clone", "--depth", "1", "https://"+dep.Repo, tempDir)
	if output, err := cmd.CombinedOutput(); err != nil {
		return nil, errors.Errorf("git clone: %w: %s", err, string(output))
	}

	// fetch the tags
	cmd = exec.Command("git", "fetch", dep.Ref)
	cmd.Dir = tempDir
	if output, err := cmd.CombinedOutput(); err != nil {
		return nil, errors.Errorf("git fetch: %w: %s", err, string(output))
	}

	// Checkout the specified reference
	cmd = exec.Command("git", "checkout", dep.Ref)
	cmd.Dir = tempDir
	if output, err := cmd.CombinedOutput(); err != nil {
		return nil, errors.Errorf("git checkout: %w: %s", err, string(output))
	}

	// get the commit hash
	cmd = exec.Command("git", "rev-parse", "HEAD")
	cmd.Dir = tempDir
	commitHash, err := cmd.Output()
	if err != nil {
		return nil, errors.Errorf("git rev-parse: %w", err)
	}
	commit := strings.TrimSpace(string(commitHash))

	depFiles := &DepFiles{
		DepInfo: dep,
		Files:   make(map[string][]byte),
		Commit:  commit,
	}

	if err := depFiles.AddAllNestedProtoFiles(tempDir); err != nil {
		return nil, errors.Errorf("adding all nested proto files: %w", err)
	}

	return depFiles, nil
}

func (d *DepFiles) AddAllNestedProtoFiles(path string) error {
	files, err := filepath.Glob(filepath.Join(path, "**/*.proto"))
	if err != nil {
		return errors.Errorf("getting files: %w", err)
	}

	for _, file := range files {
		if err := d.AddFile(file); err != nil {
			return errors.Errorf("adding file: %w", err)
		}
	}

	return nil
}

func (d *DepFiles) AddFile(path string) error {
	content, err := os.ReadFile(path)
	if err != nil {
		return errors.Errorf("reading file: %w", err)
	}

	d.Files[path] = content

	return nil
}

func (d *DepFiles) CalculateDigest() (string, error) {
	hash := sha256.New()

	for _, content := range d.Files {
		_, err := hash.Write(content)
		if err != nil {
			return "", errors.Errorf("writing to hash: %w", err)
		}
	}

	return hex.EncodeToString(hash.Sum(nil)), nil
}

func (d *DepFiles) WriteToDir(relPath string) error {
	if err := os.MkdirAll(relPath, 0755); err != nil {
		return errors.Errorf("creating output directory: %w", err)
	}
	for ipath, content := range d.Files {
		if err := os.WriteFile(filepath.Join(relPath, ipath), content, 0644); err != nil {
			return errors.Errorf("writing file: %w", err)
		}
	}

	// write a commit.txt file
	if err := os.WriteFile(filepath.Join(relPath, "commit.txt"), []byte(d.Commit), 0644); err != nil {
		return errors.Errorf("writing commit file: %w", err)
	}

	return nil
}

func (d *DepFiles) LockEntry() (*LockDep, error) {
	digest, err := d.CalculateDigest()
	if err != nil {
		return nil, errors.Errorf("calculating digest: %w", err)
	}

	return &LockDep{
		Type:   d.DepInfo.Type,
		Repo:   d.DepInfo.Repo,
		Path:   d.DepInfo.Path,
		Ref:    d.DepInfo.Ref,
		Commit: d.Commit,
		Digest: digest,
	}, nil
}

// compare two lock entries
func (l *LockDep) Compare(other *LockDep) bool {
	return l.Repo == other.Repo && l.Path == other.Path && l.Ref == other.Ref && l.Commit == other.Commit && l.Digest == other.Digest
}

func (me *LockFile) EntryFor(dep Buf3pdDep) *LockDep {
	for _, dep := range me.Deps {
		if dep.Compare(dep) {
			return dep
		}
	}
	return nil
}
